<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>深入理解synchronized关键字</title>
    <url>/2021/01/13/understand_synchronized_keyword/</url>
    <content><![CDATA[<h2 id="synchronized与原子性"><a href="#synchronized与原子性" class="headerlink" title="synchronized与原子性"></a>synchronized与原子性</h2><p>先来看一个大家很熟悉的例子：<br><a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerIncrementer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段很简单的代码，在单线程中不会有任何问题。但是如果在多线程的环境当中，运行结果就很有可能并不是我们所想的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IntegerIncrementer incrementer = <span class="keyword">new</span> IntergerIncrementer();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Demo());</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"result: "</span> + incrementer.getCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        incrementer.increase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码开了1000个线程，每个线程做的事情很简单，就是让incrementer自增，但是最后的结果却并不一定是1000。这是因为<code>count++</code>并不是一个原子性的操作，所谓原子性，就是指线程在执行这个指令的时候不会被打断，不会发生context switch。一个<code>count++</code>的操作，实际上包含了以下三步：</p>
<ol>
<li>读取count的值。</li>
<li>对count加一。</li>
<li>将加一后的值赋值给count。</li>
</ol>
<p>即使一般而言，1和3的操作在java中都被认为是具有原子性的（<strong>注意long和double在32位架构的CPU下不是原子操作，会分开成两次32位的读或者写</strong>），但是这三种操作组合起来并不具有原子性。比如可能发生以下情况：</p>
<ol>
<li>线程A读取了count的值为9，对其加一。</li>
<li>在线程A赋值之前，线程B也读取了count的值为9，对其加一。</li>
<li>线程A对count赋值为10。</li>
<li>线程B对count赋值为10。</li>
</ol>
<p>2的情况中，我们并不一定要求在线程A赋值之前B去读count这个情况才可能发生，因为即使线程A写入了，也不一定对B可见，这个我们之后在讨论。</p>
<p>在以上的情况中，count本应该最后变为11，但是最后的值却为10。很明显，在多线程环境中，我们无法确定程序最后输出的结果是什么，因为其完全取决于线程运行的情况。所以我们希望<code>count++</code>这个操作可以具有原子性，为了达到这个目的，我们可以用<code>synchronized</code>关键字。</p>
<p><code>synchronized</code>可以用在以下场景：</p>
<ol>
<li>静态方法: <code>public static synchronized void method() { ... }</code></li>
<li>实例方法: <code>public synchronized void method() { ... }</code></li>
<li>类对象: <code>synchronized (Demo.class) { ... }</code></li>
<li>实例对象: <code>synchronized (this) { ... }</code></li>
</ol>
<p>每一个java的对象都有对应的monitor lock，这个monitor lock会在进入synchronized block的时候被线程自动获取，然后在离开的时候释放。这个锁一旦被某个线程获取，其他线程都无法获取，只能block，等占有的线程释放之后，再尝试获取。值得注意的是，java的monitor lock是可以重复获取的，如果一个线程已经获取了这个锁，那么当它再次请求的时候，这个锁对应的计数器会加一，每一次离开synchronized block都会减一，直到减为0，锁就会释放。举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">do</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Do something...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span> <span class="keyword">extends</span> <span class="title">BaseClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">do</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Do something...</span></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">do</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们直接调用<code>ChildClass</code>的<code>do()</code>方法，那么当前线程会获取<code>ChildClass</code>和<code>BaseClass</code>的monitor lock，那么当其调用<code>super.do()</code>的时候，会尝试再次获取<code>BaseClass</code>的monitor lock，如果不允许重复获得锁的话，这个锁是被当前线程拥有，所以不可能再次获得，那么只会deadlock。</p>
<p>需要注意的是对象的monitor lock的和对选哪个本身的状态并没有太大的关系。获得了对象的monitor lock并不会防止其他线程访问对象，只会防止其他线程获得相同的monitor lock，其他线程仍然可以访问对象没有被<code>synchronized</code> guard的代码。</p>
<p>具体是使用synchronized method还是synchronized block，这取决与具体的情况，但是一般都需要注意避免在里面放入一些费时的操作，比如昂贵的计算、网络或者I/O请求。</p>
<h2 id="synchronized与可见性"><a href="#synchronized与可见性" class="headerlink" title="synchronized与可见性"></a>synchronized与可见性</h2><p>还是上面的例子，如果我们改成这样是不是就没问题了呢?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerIncrementer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很遗憾，答案是否定的。这里又会涉及到另一个问题，就是可见性的问题。简而言之，就是线程A的操作不一定马上对线程B可见。在JMM(Java Memory Model)的设计中，共享变量储存在主内存当中，每一个线程又会有自己的工作内存，这一块区域只对这个线程可见，线程对共享变量进行操作的时候会先读取到工作内存，修改然后在写回去。那么完全可能出现以下情况：</p>
<ol>
<li>线程A从主内存读取counter，在工作内存中加一，写入工作内存的变量。</li>
<li>线程B从主内存读取counter。</li>
<li>线程A把counter写入主内存。</li>
</ol>
<p>这样一来线程B最后读到的数据是stale data，再一次地，程序的运行结果取决于线程的运行的状况，输出无法预测。</p>
<p>同样我们可以利用<code>synchrnized</code>来解决这个问题，<code>synchronized</code>可以保证线程在释放锁的时候强制将值刷新到主内存，这样当释放锁的时候，新的值就即使对其他线程可见，保证了对共享变量更改的可见性。</p>
<p>所以当对共享变量进行操作的时候，如果有线程写入的话，读和写都需要进行加锁。</p>
<p>当然我们也可以使用<code>volite</code>关键字来达到可见性，我们会在另外的文章中进行讨论。</p>
<h2 id="synchronized与有序性"><a href="#synchronized与有序性" class="headerlink" title="synchronized与有序性"></a>synchronized与有序性</h2><p>在编程语言中，程序员所写的代码的顺序和最后机器执行的顺序并不一定是一样的，这是因为底层的编译器和处理器，包括JVM会对指令进行优化，从而达到更好的performance。对于一段代码只要在遵从<code>as-if-serial</code>语义的前提下——即无论如何重排序，单线程执行的结果不会改变——就可以对指令进行重排。在JMM中，因为多线程的情况，其会限制一些指令的重排，当然程序员也可以利用一些关键字来防止重排，这里我们不做深入讨论。</p>
<p>这里有序性指的是，程序是否按照代码的顺序执行，不会被底层的一些处理而重排。</p>
<p><code>synchronized</code>并无法防止指令的重排，但其在一定程度上提供了有序性：</p>
<ol>
<li>所有synchronized block同时只能有一个线程进入，这保证了block之间的有序性。</li>
<li>其会防止释放monitor lock和在block中写入变量的指令之间的重排，这保证了释放锁的时候，更新的值已经写入了主内存。</li>
</ol>
<p>但是对于block中的指令，并没有办法防止重排。因为block中始终是单线程，只要遵从<code>as-if-serial</code>语义，即可重排。</p>
]]></content>
      <categories>
        <category>Programming</category>
        <category>Java</category>
        <category>Concurrency</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>Paper Reading: Kafka</title>
    <url>/2021/01/03/paper_reading_kafka/</url>
    <content><![CDATA[<p><a href="http://notes.stephenholiday.com/Kafka.pdf" target="_blank" rel="noopener">Kafka</a> is a distributed messaging system that developed for collecting and delivering high volumes of log data with low latency.<br><a id="more"></a></p>
<h2 id="Basic-Concepts"><a href="#Basic-Concepts" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h2><p>A stream of message of a particular type is defined by a topic. A producer can publish messages to a topic. The pushed messages are then stored at a set of servers called brokers. </p>
<p>Kafka uses pull model instead of push, in which the broker forwards data to consumers, since each consumer can retrieve the messages at themaximum rate it can sustain and avoid being flooded by messages pushed faster than it can handle.</p>
<p>To subscribe a topic, a consumer first creates one or more message streams for the topic. The messages published to that topic will be evenly distributed into these sub-streams. The message stream iterator never terminates. If there are currently no more messages to consume, the iterator blocks until new messages are published to the topic.</p>
<p>Kafaka supports both the point-to-point delivery modelin which multiple consumers jointly consume a single copy of all messages in a topic, as well as the pub/sub model in which multiple consumers each retrieve its own copy of a topic.</p>
<p>To balance load, a topic is divided into multiple partitions and each broker stores one or more of those partitions. Multiple producers and consumers can publish and retrieve messages at the same time.</p>
<h2 id="Design-Principles"><a href="#Design-Principles" class="headerlink" title="Design Principles"></a>Design Principles</h2><p>Kafka has a very simple storage layout. Each partition of a topic corresponds to a logical log. Physically, a log is implemented as a set of segment files of approximately the same size (e.g. 1GB). Kafka flushes the segment file to disk only after a configurable number of messages have been published or a certain amount of time has elapsed, A message is only exposed to the consumer after it is flushed.</p>
<p>Each message in Kafka is addressed by its logical offset in the log. Thus the message ids are increasing but not consecutive. A consumer always consume messages from particular partition sequentially. Under the cover, the consumer is issuing asynchronous pull requests to the broker to have a buffer of data ready for the application to consume. Each pull request contains the offset of the message from which the consumption begins and an acceptable number of bytes to fetch. Each broker keeps in memory a sorted list of offsets as index, including the offset of the first message in every segment file.</p>
<p>Kafka avoid explicitly caching messages in memory at the Kafka layer. Instead, it relys on the underlying file system page cache which benefits the sequential access, normal operating system caching heuristics are very effective.</p>
<p>Kafka exploit the sendfile API to avoid extra copy from page cache to application buffer and kernel buffer, and efficiently deliver bytes in a log segment file from a broker to a consumer.</p>
<p>In Kafka, the information about how much each consumer has consumed is not maintained by the broker, but by the consumer itself. This design decision results in a stateless broker. However, this makes it tricky to delete a message since a broker doesn’t know whether all subscribers have consumed the message. Kafka solves this problem by using a simple time-based SLA for the retention policy.</p>
<p>One important benefit of this design is that a consumer can deliberately <strong>rewind</strong> back to an old offset and re-consume data. One example is that the consumer application might flush the data to disk periodically. If the consumer crashes, the unflushed data is lost. In this case, the consuemr can checkpoint the smallest offset of the unflushed messages and re-consume from that offset when it is restarted. Rewind is much easier to support in pull model than push model.</p>
<h2 id="Producer-amp-Consumer-Coordination"><a href="#Producer-amp-Consumer-Coordination" class="headerlink" title="Producer &amp; Consumer Coordination"></a>Producer &amp; Consumer Coordination</h2><p>Each producer can publish a message to either a random selected partition or a partition semantically determined by a partitioning key and a partitioning fucntion.</p>
<p>Each <strong>consumer group</strong> consists of one or more consumers that jointly consume a set of subscribed topics. Different consumer groups each independently consume the full set of subscribed messages and no coordination is needed across consumer groups.</p>
<p>To make the coordination easier, the first decision is to make a partition within a topic the smallest unit of parallelism. This means at any given time, all messages from one partition are consumed only by a single consumer within each consumer group. The second decision is to not have a master node, but instead let consumers coordinate among themselves in a decentralized fashion since adding master can complicated the system, for example, master failure needs to be handled.</p>
<p>Thus Kafka uses <a href="https://kanrourou.github.io/2021/01/02/paper_reading_zookeeper/" target="_blank" rel="noopener">ZooKeeper</a> for coordinating following tasks:</p>
<ol>
<li>Detecting the addition and the removal of brokers and consumers.</li>
<li>Triggering a rebalance process in each consumer when the above events happen.</li>
<li>Maintaining the consumption relationship and keeping track of the consumed offset of each partition (per consumer group).</li>
</ol>
<p>Specifically, when each broker or consumer starts up, it stores its information in a broker or consumr registry in ZooKeeper. The broker registry contains the broker’s host name and port, and the set of topics and partitions it stored on it. The consumer registry includes the consumer group to which a consumer belongs and the set of topics that it subscribes to. Each consumer group is associated with an ownership registry and an offset registry in ZooKeeper. The ownership registry has one path for every subscribed partition and the consumer which currently owns this partition. The offset registry stores last consumed offset of the messages in the partition.</p>
<p>The ZooKeeper node created for broker registry, consumer registry and ownership registry is ephemeral, and persistent for the offset registry. If a broker fails, all partition on it are automatically removed from the broker registry. Same as consumer, which causes it to lose its entry in the consumer registry and all partitions it owns in ownership registry. Each consumer registers a ZooKeeper watcher on both broker and consumer registry, and will be notified when ther is a broker set or consumer group change. A rebalance process will be initialized to determine the new subset of partition each consumer should consume from when receiving notification, please refer to the orginal article for more details.</p>
<p>The notification may come at slightly different times at the consuemrs. So it is possible that one consumer tries to take ownership of a partition stilled owned by another consumer. When this happens, the first consumer simply release all the partitions that it currently owns, wait a bit and retries the reblance process.</p>
<h2 id="Guarantees"><a href="#Guarantees" class="headerlink" title="Guarantees"></a>Guarantees</h2><p>In general, Kafka only guarantees at-least-once delivery. Most of time, the message is delivered exactly once to each consumer group. In case when a consumer process crashes without a clean shutdown, after it restarts, it might get duplicates after the last offset successfully commited to ZooKeeper.</p>
<p>Kafka guarantees that messages from a single partition are delivered to a consumer in order. However, there is no guarantee on the ordering of messages coming from differernt partitions.</p>
<p>To avoid log corruption, Kafka stores CRC (Cyclic Redundancy Check) for each message in the log.</p>
<p>The paper doesn’t discuss about replications in Kafka, but it should already be supported.</p>
]]></content>
      <categories>
        <category>System Infrastructure</category>
        <category>MessageQueue</category>
      </categories>
      <tags>
        <tag>Distributed System</tag>
        <tag>Infrastructure</tag>
        <tag>Paper Reading</tag>
      </tags>
  </entry>
  <entry>
    <title>Use Valine to set up blog comments and PV</title>
    <url>/2021/01/03/valine_for_pv_and_comments/</url>
    <content><![CDATA[<p>We have introduced one <a href="https://kanrourou.github.io/2019/03/18/hexo_next_page_user_views/" target="_blank" rel="noopener">way</a> before to configure blog PV by using the natrually supported LeanCloud counter in NexT theme. But this is somehow broken for my site, so I explored and switched to <a href="https://valine.js.org/" target="_blank" rel="noopener">Valine</a> which supports PV and comments without any backend changes.<br><a id="more"></a></p>
<h3 id="Set-up-LeanCloud"><a href="#Set-up-LeanCloud" class="headerlink" title="Set up LeanCloud"></a>Set up LeanCloud</h3><p>The LeanCloud set up is pretty similar to what have been explained in the article above, please refer to it for more details. In general, after creating your application, you will need to create <code>Counter</code> and <code>Comment</code> classes under <code>Storage-&gt;Objects</code>, note that the class name must not be changed. And the ACL permission needs to be set to allow all users to read &amp; write.</p>
<p><img src="/images/leancloud_classes_permission.png" alt></p>
<p>Navigate to the security page, turn off all services except LeanStorage, and add your blog domain to web secure domains.</p>
<p><img src="/images/leancloud_security.png" alt></p>
<h3 id="Update-config-file"><a href="#Update-config-file" class="headerlink" title="Update config file"></a>Update config file</h3><p>Go to this <a href="https://www.jsdelivr.com/package/npm/valine" target="_blank" rel="noopener">page</a> to access Valine CDN files.</p>
<p><img src="/images/valine_cdn.png" alt></p>
<p>Copy the script url and modify <code>themes/next/_config.yml</code> as below:<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Valine</span></span><br><span class="line"><span class="comment"># valine: //cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js</span></span><br><span class="line"><span class="comment"># valine: //cdnjs.cloudflare.com/ajax/libs/valine/1.3.4/Valine.min.js</span></span><br><span class="line"><span class="attr">valine:</span> <span class="attr">https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js</span></span><br></pre></td></tr></table></figure></p>
<p>Navigate to app keys page to acquire your <code>appid</code> and <code>appkey</code>.</p>
<p><img src="/images/lean_cloud_app_key.png" alt></p>
<p>Then turn on Valine in the config file:<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Valine</span></span><br><span class="line"><span class="comment"># More info available at https://valine.js.org</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span> </span><br><span class="line"><span class="attr">  appid:</span> <span class="comment">#your id#</span></span><br><span class="line"><span class="attr">  appkey:</span> <span class="comment">#your key#</span></span><br><span class="line"><span class="attr">  notify:</span> <span class="literal">false</span> <span class="comment"># mail notifier, See: https://github.com/xCss/Valine/wiki</span></span><br><span class="line"><span class="attr">  verify:</span> <span class="literal">false</span> <span class="comment"># Verification code</span></span><br><span class="line"><span class="attr">  placeholder:</span> <span class="string">Just</span> <span class="string">go</span> <span class="string">go...</span> <span class="comment"># comment box placeholder</span></span><br><span class="line"><span class="attr">  avatar:</span> <span class="string">mm</span> <span class="comment"># gravatar style</span></span><br><span class="line"><span class="attr">  guest_info:</span> <span class="string">nick,mail,link</span> <span class="comment"># custom comment header</span></span><br><span class="line"><span class="attr">  pageSize:</span> <span class="number">10</span> <span class="comment"># pagination size</span></span><br><span class="line"><span class="attr">  visitor:</span> <span class="literal">true</span> <span class="comment"># leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors' for counter compatibility. Article reading statistic https://valine.js.org/visitor.html</span></span><br><span class="line"><span class="attr">  comment_count:</span> <span class="literal">true</span> <span class="comment"># if false, comment count will only be displayed in post page, not in home page</span></span><br></pre></td></tr></table></figure></p>
<p>You can also enable the <code>visitor</code> which will display the number of views of your posts. Notes this conflicts with LeanCloud counter so you need to turn it off in the config file.</p>
<p>Deploy the changes and you will see the comments and PV:</p>
<p><img src="/images/comments.png" alt></p>
<p><img src="/images/comments_pv_header_view.png" alt></p>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>The PV counter uses title combing publish date as the key. To avoid that updating the article will cause the PV to be reset, you can add the publish date in you article:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">date: 2021-01-03 15:25:41</span><br></pre></td></tr></table></figure></p>
<p>And turn off the <code>future</code> in Hexo’s <code>_config.yml</code>.<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">future:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<p>So the posted date will not be changed after you modified it, and the previous PV count will be kept.</p>
]]></content>
      <categories>
        <category>Programming</category>
        <category>JavaScript</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>JavaScript</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>Paper Reading: ZooKeeper</title>
    <url>/2021/01/02/paper_reading_zookeeper/</url>
    <content><![CDATA[<p><a href="https://www.usenix.org/legacy/events/atc10/tech/full_papers/Hunt.pdf" target="_blank" rel="noopener">ZooKeeper</a> is a service for coordinating processes of distributed applications, which provides wait-free coordination for Internet-scale systems.<br><a id="more"></a></p>
<h2 id="Design-Decisions"><a href="#Design-Decisions" class="headerlink" title="Design Decisions"></a>Design Decisions</h2><p>Moved away from implementing specific primitives on the server side, opted for exposing an API that enables application developers to implement their own primitives, which enables new primitives without requiring changes to the service core.</p>
<p>Moved away from blocking primitives, such as locks (e.g. Chubby). Since blocking primitives can cause, among other problems, slow or faulty clients to impact negatively the performance of faster clients. Instead, ZooKeeper implements an API that manipulates simple wait-free data objects (znodes) organized hierarchically as in file systems.</p>
<p>ZooKeepers guarantees two following properties for client operations:</p>
<ol>
<li>FIFO client order: all requests from <strong>a given client</strong> are executed in the order that they were sent by the client. Note this order guarantee is per client level, for example, read operation order is not guaranteed among clients, since read operations are handled locally by the connected server.</li>
<li>Linearizable writes: all requests that update the state of ZooKeeper are serializable and respect precendence. This is guaranteed by implementing a leader-based atomic broadcast protocol, called Zab.</li>
</ol>
<p>Improve read performace by caching data on the client side, for example, the process can cache the identifier fo the current leader instead of probing ZooKeeper every time in needs to know the leader. ZooKeepers uses a watch mechanism, with this mechanism, a client can watch for an update to a given data object and receive a notification upon an update.</p>
<h2 id="Service-Overview"><a href="#Service-Overview" class="headerlink" title="Service Overview"></a>Service Overview</h2><p>The ZooKeeper provides to its clients the abstraction of a set of data nodes (znodes), organized according to a hierarchical name space, referred by the standard UNIX notation for file system paths. All znodes store data, and all znodes, except for <strong>ephemeral znodes</strong>, can have children. There are two types of znodes that a client can create:</p>
<ol>
<li>Regular: Clients manipulate regular znodes by creating and deleting them explicitly.</li>
<li>Ephemeral: Clients create such znodes, and they either delete them explicitly, or let the system remove them automatically when the session that creates them terminates.</li>
</ol>
<p>ZooKeepers implements watches to allow clients to receive timely notification of chanes wihout requiring polling. Watches are one-time triggers associated with a session; they are unregistered once triggered or the session closes. Watches indicate that a change has happened, but do not provide the change. Session events, such as connection loss events, are also sent to watch callbacks so that clients knows that clients know that watch events may be delayed.</p>
<p>Znodes map to abstractions of the client application, typically corresponding to meta-data used for coordination purposes. Although znodes have not been designed for general data storage, ZooKeepers does allow clients to store some information that can be used for meta-data or configuration in a distributed computation. It also has associated meta-data with time stamps and version numbers which allow clients to keep track of its status.</p>
<p>A client connects to ZooKeeper and initiates a session. ZooKeeper considers a client faulty if it does not receive anything from its session for more than that timeout.</p>
<h2 id="APIs"><a href="#APIs" class="headerlink" title="APIs"></a>APIs</h2><p>The common used APIs provided by ZooKeeper are:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create(path, data, flags), where flags enables a client to select the type of znode: regular, ephemeral, and set the sequential flag, which is a monotonicaly increaseing counter appended to its name.</span><br><span class="line">delete(path, version), continue when the version matches.</span><br><span class="line">exists(path, watch), the watch flag enables client to set a watch on the znode.</span><br><span class="line">getData(path, watch), watch flag works the same way as exists().</span><br><span class="line">setData(path, data, version), continue when the version matches.</span><br><span class="line">getChildren(path, watch).</span><br><span class="line">sync(path), flush all the pending updates.</span><br></pre></td></tr></table></figure>
<p>All methods have both sync and async version, and <strong>ZooKeeper client</strong> guarantees that the corresponding callbacks for each operation are invoked in order.</p>
<p>Refer to the paper to see example primitives implemented by these APIs, including configration management, group membership, read/write locks, etc.</p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>ZooKeeper provides high availability by replicating the data on each server. For recoverability, it forces writes to be on the disk media before they are applied to the in-memory database. And it will keep a replay log of commited operations and generate periodic snapshots of the in-memory database.</p>
<p>For read request, they are serviced from the local replica, the local replica is guaranteed to be not diverged, although at any point in time some servers have applied more transactions than others. This will introduce problem that a read operation might return stale value. To gurantee a read operation retrieves the latest updated value, a client calls sync followed by a read operation.</p>
<p>For write request, they are forwarded to a single server, called the leader. The leader executes the request and broadcast the change to followers through Zab, an atomic broadcast protocol. Zab uses majority quorums to decide on a proposal and provides stronger order guarantees than regular atomic broadcast. Write ahead log is used to keep track of all changes to the database. Zab normally only deliver messages in order and exactly once, but may redeliver a message during recovery. Because the idempotent transaction is used, the end state is still same as long as they delivered in order.</p>
<p>When taking snapshot of a ZooKeeper server, the server state is not locked, instead, it depth frist scan of the tree and atomically reading each znode and write them to disk. The result might not correspond to the state of ZooKeeper at any point in time since some subsets of the state changes are delivered during the generation of the snapshot. However, since state changes are idempotent, we can apply it multiple times as long as they are in order.</p>
<p>Servers process writes in order and do not process other wirtes or reads concurrently. This ensure strict succession of notifications. Note that servers handle notification locally, only the server that a client is connected to tracks and triggers notification for that client.</p>
<p>Each read reqeust is processed and tagged with a zxid that corresponds to the last transaction seen by the server. If the client needs to connect to a new server, the new server ensures that is view of the ZooKeeper data is at least as recent as the view of the client by checking the last zxid of the client against its last zxid. And the connection won’t be establised until the server has caught up. The client is guarateed to be able to find another server that has a recent view of the system since the client only sees changes that have been replicated to a majority of the ZooKeeper servers.</p>
<p>ZooKeeper uses timeouts to detect client session failures. If the client cannot communicate with a server to send a request, it connects to a differernt server to re-establish the session.</p>
]]></content>
      <categories>
        <category>System Infrastructure</category>
        <category>Coordination Service</category>
      </categories>
      <tags>
        <tag>Distributed System</tag>
        <tag>Infrastructure</tag>
        <tag>Paper Reading</tag>
      </tags>
  </entry>
  <entry>
    <title>于是开始奔跑</title>
    <url>/2019/12/08/run_with_the_wind/</url>
    <content><![CDATA[<p>我很佩服三浦紫苑，讲好一个故事本身就很不简单，她却偏偏选择依托在编纂辞典《编舟记》或者长跑《强风吹拂》这种让人听上去就觉得枯燥乏味的事物上，然后将一切娓娓道来。相较于其他运动而言，跑步确实听上去不那么让人热血沸腾，不像足篮排那样典型的热血物语，它并不能够给人带来和对手厮杀的压迫感，和赢得比赛、击败对手的畅快感，而更多的时候是一种与自我的搏斗。就像在动画中所说的，箱根驿传的后半段棒次奔跑在路上的时候可能一个人都看不见，所能听见的只有自己的呼吸和心跳。但正是这种习惯在孤独中让自己变得强大的姿态，才是这项运动的迷人之处。<br><a id="more"></a></p>
<p><img src="/images/haiji.png" alt></p>
<p>灰二是一切的开端，从大一到大四，一手组建出了宽政大的田径队，操办了所有队友的训练和饮食，以至于在他因过度劳累而晕倒的时候，大家才突然明白他到底付出了多少。</p>
<p>他是一个如此完美的领导者和行动派，所以才能对处在低谷的king说出“你是为我们存在的，而我也是为你们存在的”这样的话语，才能够在阿走不断地质疑声中保持团队的步调。</p>
<p>可是他又觉得自己是如此的弱小，在某个时间点，他也会怀疑自己是不是过于严苛，可能无法全员取得预选赛的资格。</p>
<p>“你知道对长跑选手来说，最棒的赞美是什么吗？是快吗？不是，是强。光跑的快没办法在长跑中脱颖而出。天候，场地，比赛的发展，体能，还有自己的精神状态——长跑选手必须冷静分析这些要素，即使面对再大的困难，也要坚韧不拔的突破难关。”</p>
<p>灰二是这部作品最懂得何谓强大的人，罗曼罗兰说过，这世上只有一种英雄主义，就是认清生活的真相后仍然热爱它。作为一个普通人。经历过漫长的低谷，不得不远离跑步，却一直挣扎着想要追上曾经的自己，我想他这就是对这句话最好的注解吧。这积蓄已久的不甘和遗憾是如此地强烈，才能让他在最后一棒中压抑住让他今后再也无法跑步的膝盖伤痛，以区间第二的成绩让宽政大进入前十。</p>
<p>你亲手开启了这个故事，并为它写上了最美的结局。</p>
<p>你明明已经是个如此坚强的跑者了，却依然无法战胜人生。</p>
<p><img src="/images/king.png" alt></p>
<p>King就是我们自己。</p>
<p>生活和工作上的压力让人无处遁形。于是我们觉得不能再像孩子一样无忧无虑了，不再年轻，没有放纵的资本。</p>
<p>看着大家为了箱根驿传这种不切实际的事情努力的身影，甚至还会嘲讽几句。</p>
<p>自己，还有更重要的事情要做；自己，并不属于这里。</p>
<p>所以我们选择关闭自己的门，和他人隔绝起来，然后把这叫做长大。</p>
<p>可是我却无法讨厌这样的king，因为我无法讨厌那个弱小的自己。</p>
<p>但是我想king是很幸运的，因为他并不是孤独的国王。</p>
<p>跑步并不能让你找到工作，但它可能成为一个契机。</p>
<p>停下来，就会感到不安，我们都有过这样的时期。</p>
<p>只有在跑步的时候，我才感觉自己是在前进的。</p>
<p>所以向前跑吧，尽管不知道有什么样的未来在那边等着，但如果不收拾好心情重新出发的话，是无法到达的。</p>
<p><img src="/images/yuki.png" alt></p>
<p>阿雪是这部作品最理性的人，他清楚地知道自己想要的是什么。</p>
<p>父亲的离世让他过早地成熟起来，眼见母亲独自一人日复一日地工作到深夜，将他拉扯成人，所以自己也决定早日找到一份安稳的工作，让母亲过上好日子。一直准备参加司法考试并在毕业之前通过，这之间的困难，大家应该都心知肚明，但也不见阿雪对别人提起。</p>
<p> 但母亲再婚的决定却让阿雪收到了巨大的打击，明明母亲已经获得了幸福，却和自己的设想不一样。母亲再婚之后很快就有了第二个孩子，自己似乎并没有办法融入新的家庭，于是考上大学就决定搬出去，也没有回过几次家。</p>
<p>但看到为自己特地赶来加油的家人们，心里那微不足道的芥蒂也开始慢慢融化了。他们一直都把自己当作家人，然而我却一直没有对他们敞开心扉。</p>
<p>跑起来，真的可以改变很多事情，在意想不到的地方。</p>
<p>在跑第六区间的时候，借着山路之力，阿雪也曾产生过“这样跑下去，是不是就能追上阿走”的想法，也似乎明白了对跑步的热爱从何而来。 但他也清楚地知道那是一条危险的、充满荆棘的道路，自己的未来并不在那里。</p>
<p>再快两秒就可以拿到区间赏了，但那两秒，是自己永远都无法超越的两秒。</p>
<p>不被选中的人是注定无法取得胜利的，那么他们一直跑下去的理由是什么呢？</p>
<p>但是不跑起来，是无法看到这个美丽的世界的，即使深知自己今日就要和它道别。</p>
<p><img src="/images/kakeru.png" alt></p>
<p>阿走的成长贯穿了整个作品的主线。</p>
<p>因为看不下去教练对待队友的方式爆发冲突而远离赛场，得不到任何人的理解，甚至连自己的队友也因为被禁赛而迁怒于他。</p>
<p>失去了保送田径名校的资格，进入了宽政大。甚至连自己的生活费也挥霍一空，只能靠偷便利店的面包裹腹。</p>
<p>那种压到你喘不过气的绝望，灰二也曾经历过。所以他才会再遇到阿走的时候那么确信，自己找到了第十个人。</p>
<p>但自己不相信仅仅凭借这随意拼凑的十个人可以站上去往箱根的赛场，怀疑、争吵、责备，被过去所束缚的走似乎并没有办法跑出笼罩在前方的阴霾。</p>
<p>尽管自己依然在不停的奔跑，但好像在逃避着什么，成绩没有提高，自己也日复一日地更加焦虑。</p>
<p>但幸好他有温暖的竹青庄，队友的宽容，学长的开导，和自己亲眼目睹的所有人为了同一个目标而奔跑的身姿。</p>
<p>因为你总是跑在前面，所以才看不到啊，在你身后拼命想追上你的我们。</p>
<p>于是阿走也开始学会关心他人，学会停下来，为奔跑的人呐喊。这是自己独自奔跑时没有过的经历，这是只有和大家一起奔跑时才能看到的风景。</p>
<p>所以当阿走发自内心地说出“我想我们这十个人，一起参加箱根驿传”的时候，我哭了，真好啊，藏原走，你遇到了那群把你变的更好的人。</p>
<p>三浦紫苑想讲的是人生。人生并不是一场马拉松，大家的起点并不相同，也并没有终点可言，但是我们却切切实实地奔跑在路上。可能孤独了许久，又或是遇到了志同道合的伙伴，就像是竹青庄的十个人，处在人生不同的阶段，怀抱着不同的理由，但大家还是一起站上了箱根驿传的赛场，传递着属于自己的一棒。</p>
<p>为什么要跑步？这是竹青庄一众最开始的问题，直到结尾作品也没有给我们一个明确的答案，但最后似乎所有人都收获了什么。</p>
<p>不是因为喜欢所以才认真，而是想着认真起来，说不定就喜欢上了。</p>
<p>因为奔跑的时候，我才感觉自己是纯净的。</p>
<p>因为现实并不会消失，那干脆不要逃避，和现实一起奔跑。</p>
<p>因为想跑的更快，知道自己的极限在哪里。</p>
<p>因为跑起来，才能看到之前不曾见过的风景。</p>
<p>开始跑步的原因可以有很多，坚持下去的理由也不尽相同，即使一直奔跑也会有停下来的一天。但是至少现在，请一直奔跑下去吧。也许并不知道前方会有什么风景，会遇到什么人，但是也请一直奔跑下去，因为我们现在所处的生活，就是我们的跑道。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo: Adding PV/UV  counters to NexT theme</title>
    <url>/2019/03/18/hexo_next_page_user_views/</url>
    <content><![CDATA[<h2 id="Site-PV-UV"><a href="#Site-PV-UV" class="headerlink" title="Site PV/UV"></a>Site PV/UV</h2><p>NexT supports integration with different metrics/analytics services, which you can check on their <a href="https://theme-next.iissnan.com/third-party-services.html#analytics-system" target="_blank" rel="noopener">website</a>. To track the PV/UV for the whole site, we choose <a href="http://ibruce.info/2015/04/04/busuanzi/" target="_blank" rel="noopener">busuanzi</a>, since it supports displaying those information on your webpage.<br><a id="more"></a></p>
<h3 id="Install-busuanzi-js"><a href="#Install-busuanzi-js" class="headerlink" title="Install busuanzi.js"></a>Install busuanzi.js</h3><p>NexT already integrates busuanzi, but based on their <a href="http://ibruce.info/2015/04/04/busuanzi/" target="_blank" rel="noopener">website</a>, busuanzi has to change their host name for some reasons and the old one is not compatibale anymore, we have to fix this problem by ourselves. To fix it, simply navigate to <code>themes/next/layout/_third-party/analytics/busuanzi-counter.swig</code> and change<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;script async src=<span class="string">"//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>to<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;script async src=<span class="string">"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="Congifure-NexT"><a href="#Congifure-NexT" class="headerlink" title="Congifure NexT"></a>Congifure NexT</h3><p>To enable busuanzi in NexT, we need to configure <code>_config.yml</code> under <code>themes/next</code>. Search for <code>busuanzi_count</code> and modify based on your requirement<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  <span class="comment"># count values only if the other configs are false</span></span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># custom uv span for the whole site</span></span><br><span class="line">  site_uv: <span class="literal">true</span></span><br><span class="line">  site_uv_header: &lt;i class=<span class="string">"fa fa-user"</span>&gt;&lt;/i&gt;</span><br><span class="line">  site_uv_footer: </span><br><span class="line">  <span class="comment"># custom pv span for the whole site</span></span><br><span class="line">  site_pv: <span class="literal">true</span></span><br><span class="line">  site_pv_header: &lt;i class=<span class="string">"fa fa-eye"</span>&gt;&lt;/i&gt;</span><br><span class="line">  site_pv_footer:</span><br><span class="line">  <span class="comment"># custom pv span for one page only</span></span><br><span class="line">  page_pv: <span class="literal">false</span></span><br><span class="line">  page_pv_header: &lt;i class=<span class="string">"fa fa-file-o"</span>&gt;&lt;/i&gt;</span><br><span class="line">  page_pv_footer:</span><br></pre></td></tr></table></figure></p>
<p>The above configuration only enables site_uv and site_pv, you can also customize the header and footer to make it more expressive. I disabled the page_pv since it only supports displaying visitors in the artical page, which means you can’t see it in home page, and we have a better replacement for it.<br>Update the settings and run <code>hexo s</code>, you will see the data in the footer:</p>
<p><img src="/images/site_pv_uv.png" alt></p>
<p>It currently displays all the counts to <code>http://localhost:4000</code>, once you deploy it, you will see the actual data of your website.</p>
<h2 id="Page-PV"><a href="#Page-PV" class="headerlink" title="Page PV"></a>Page PV</h2><p>To implement page pv counter, we need the corresponding backend service. Here, we choose <a href="https://leancloud.cn/" target="_blank" rel="noopener">LeanCloud</a> which is well supported by NexT.</p>
<h3 id="Setup-LeanCloud"><a href="#Setup-LeanCloud" class="headerlink" title="Setup LeanCloud"></a>Setup LeanCloud</h3><p>Create a LeanCloud account and then create a new application with the name you want</p>
<p><img src="/images/lean_cloud.png" alt></p>
<p>Click the application and create a new class with name <code>Counter</code> and set the ACL permission to be unlimited</p>
<p><img src="/images/lean_cloud_counter.png" alt></p>
<p>This creates a new DB table to store the page view counter information for each of your article, the key is the combination of you title and create time. You can also manually modify each data entry to change the actually number.</p>
<h3 id="Configure-NexT"><a href="#Configure-NexT" class="headerlink" title="Configure NexT"></a>Configure NexT</h3><p>Open <code>_config.yml</code> under <code>themes/next</code> and search for leancloud<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">leancloud_visitors:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  app_id: **your_app_id**</span><br><span class="line">  app_key: **your_app_key**</span><br></pre></td></tr></table></figure></p>
<p>You can find the <code>app_id</code> and <code>app_key</code> under settings in you LeanCloud application</p>
<p><img src="/images/lean_cloud_app_key.png" alt></p>
<p>Once you deploy the change, you will see the new page visitor counter in your articles.</p>
<p><img src="/images/page_pv.png" alt></p>
]]></content>
      <categories>
        <category>Programming</category>
        <category>Javascript</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>JavaScript</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>Create your own blog with Hexo and Github Pages</title>
    <url>/2019/03/17/hexo_github_pages_blog/</url>
    <content><![CDATA[<h2 id="Set-up-local-development-environment-on-MacOS"><a href="#Set-up-local-development-environment-on-MacOS" class="headerlink" title="Set up local development environment on MacOS"></a>Set up local development environment on MacOS</h2><h3 id="Install-Node-js"><a href="#Install-Node-js" class="headerlink" title="Install Node.js"></a>Install Node.js</h3><p>Hexo is based on Node.js which can be installed <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">here</a>. It comes with npm, once the installation is done, run the following commands to make sure it is installed successfully<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="Install-Git"><a href="#Install-Git" class="headerlink" title="Install Git"></a>Install Git</h3><p>Follow the <a href="https://git-scm.com/book/en/v2/Getting-Started-Installing-Git" target="_blank" rel="noopener">steps</a> to install Git on your machine and verify by running<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git --version</span><br><span class="line">git version 2.17.2 (Apple Git-113)</span><br></pre></td></tr></table></figure></p>
<h3 id="Install-Hexo"><a href="#Install-Hexo" class="headerlink" title="Install Hexo"></a>Install Hexo</h3><p>Hexo can be installed from npm<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo npm install -g hexo</span><br></pre></td></tr></table></figure></p>
<p>Create your personal blog folder, cd into it. And run the following command to initialze and install all required packages<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init</span><br><span class="line">sudo npm install</span><br></pre></td></tr></table></figure></p>
<p>Once it is done, run<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure></p>
<p><code>hexo generate</code> or <code>hexo g</code>  will generate all static files, and <code>hexo server</code> or <code>hexo s</code> starts a local server and you can navigate to <code>http://localhost:4000</code> in browser to see your blog. Once the local server is started, hexo will watch for file updates automatically, so you don’t need to restart the server, simply refreshing the page and you will see the changes.</p>
<h2 id="Create-a-Github-Pages-project"><a href="#Create-a-Github-Pages-project" class="headerlink" title="Create a Github Pages project"></a>Create a Github Pages project</h2><p>What is Github Pages? According to the official website:</p>
<blockquote>
<p>GitHub Pages is a static site hosting service designed to host your personal, organization, or project pages directly from a GitHub repository</p>
</blockquote>
<p>As stated above, GitHub Pages is a static site hosting service, which means it doesn’t support server side programming. But it is good enough for building a personal blog, people may want to add some cool dynamic website features, which won’t be a problem. Hexo and different thirdparty tools can help us with it, we will talk about it later.<br>To use Github Pages, we need to create and configure our github account, we won’t dive deep into this part, there are a lot of related resouces can be easily googled. Once the Github account is set up, create a repository named as <code>&lt;username&gt;.github.io</code>.</p>
<h2 id="Link-Github-Pages-project-to-your-local-repository"><a href="#Link-Github-Pages-project-to-your-local-repository" class="headerlink" title="Link Github Pages project to your local repository"></a>Link Github Pages project to your local repository</h2><p>This can be easily done by modifying the config file. To do that, cd into you blog folder and open <code>_config.yml</code> with whatever text editor you like, and adding the following deploy configration to the file<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: https://github.com/&lt;username&gt;/&lt;username&gt;.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p>
<p>To deploy on server, we need to install git deployer by<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>
<p>then run<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></p>
<p>or<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure></p>
<p>to deploy your project. Every time after you make some changes, you can follow the workflow above to view your changes locally then deploy. If you can’t see the changes after depolyment, you can run<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure></p>
<p>to clean the cached and generated files.</p>
<h2 id="Select-a-Theme"><a href="#Select-a-Theme" class="headerlink" title="Select a Theme"></a>Select a Theme</h2><p>Hexo has a variety of themes you can select from the <a href="https://hexo.io/themes/index.html" target="_blank" rel="noopener">offical website</a>. This blog is powered by <a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">NexT</a>. To install it, cd into your blog folder and run<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></p>
<p>This will clone the NexT project to your local repository. To enable the new theme, open <code>_config.yml</code>, under <code>theme</code>,  change <code>landscape</code> to <code>next</code> and deploy it.</p>
<p>The next article will discuss about theme configuration and third party integration tools.</p>
]]></content>
      <categories>
        <category>Programming</category>
        <category>JavaScript</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
</search>
