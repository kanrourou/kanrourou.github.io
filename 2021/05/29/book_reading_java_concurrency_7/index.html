<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="Task cancellationAn activity is cancellable if external code can move it to completion before its normal completion.">
<meta name="keywords" content="Book Reading,Java,Concurrency,CPJ">
<meta property="og:type" content="article">
<meta property="og:title" content="Book Reading: Java Concurrency in Practice, Chapter 7">
<meta property="og:url" content="http://yoursite.com/2021/05/29/book_reading_java_concurrency_7/index.html">
<meta property="og:site_name" content="码字的呵呵君">
<meta property="og:description" content="Task cancellationAn activity is cancellable if external code can move it to completion before its normal completion.">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2021-05-29T20:48:16.460Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Book Reading: Java Concurrency in Practice, Chapter 7">
<meta name="twitter:description" content="Task cancellationAn activity is cancellable if external code can move it to completion before its normal completion.">

<link rel="canonical" href="http://yoursite.com/2021/05/29/book_reading_java_concurrency_7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Book Reading: Java Concurrency in Practice, Chapter 7 | 码字的呵呵君</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-133451584-2"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-133451584-2');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">码字的呵呵君</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">漫长的告别</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/05/29/book_reading_java_concurrency_7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hehejun">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码字的呵呵君">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Book Reading: Java Concurrency in Practice, Chapter 7
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-05-29 00:00:00 / Modified: 13:48:16" itemprop="dateCreated datePublished" datetime="2021-05-29T00:00:00-07:00">2021-05-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index">
                    <span itemprop="name">Programming</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/Java/Concurrency/" itemprop="url" rel="index">
                    <span itemprop="name">Concurrency</span>
                  </a>
                </span>
            </span>

          
            <span id="/2021/05/29/book_reading_java_concurrency_7/" class="post-meta-item leancloud_visitors" data-flag-title="Book Reading: Java Concurrency in Practice, Chapter 7" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2021/05/29/book_reading_java_concurrency_7/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/05/29/book_reading_java_concurrency_7/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>16 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Task-cancellation"><a href="#Task-cancellation" class="headerlink" title="Task cancellation"></a>Task cancellation</h2><p>An activity is <em>cancellable</em> if external code can move it to completion before its normal completion.<br><a id="more"></a></p>
<p>There is no safe way to preemptively stop a thread in Java, and therefore no safe way to preemptively stop a task. There are only cooperative mechanisms, by which the task and the code requesting cancellation follow an agree-upon protocol.</p>
<p>A task that wants to be cancellable must have a <em>cancellation policy</em> that specifies the “how”, “when”, and “what” of cancellation–how other code can request cancellation, when the task checks whether cancellation has been requested, and what actions the task takes in response to a cancellation request.</p>
<h3 id="Interruption"><a href="#Interruption" class="headerlink" title="Interruption"></a>Interruption</h3><p>Thread interrution is  a cooperative mechanism for a thread to signal another thread that it should, at its convenience and if it feels like it, stop what it is doing and do something else.</p>
<p>Each thread has a boolean <em>interrupted status</em>; interrupting a thread sets its interrupted status to true. <code>Thread</code> contains methods for interrupting a thread and querying the interrupted status of a thread:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Thread &#123;</span><br><span class="line">    public vlid interrupt() &#123; ... &#125;</span><br><span class="line">    public boolean isInterrupted() &#123; ... &#125;</span><br><span class="line">    public static boolean interrupted() &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>interrupt</code> method interrupts the target thread, and <code>isInterrupted</code> returns the interupted status of the target thread. The poorly named static <code>interrupted</code> method <em>clears</em> the interrupted status of the current thread and returns its previous value; this is the only way to clear the interrupted status.</p>
<p>Blocking library methods like <code>Thread.sleep</code> and <code>Object.wait</code> try to detect when a thread has been interrupted and return early. They respond to interruption by clearing the interrupted status and throwing <code>InterruptedException</code>, indicating that the blocking operation completed early due to interruption. The JVM makes no guarantees on how quickly a blocking method will detect interruption, but in practice this happens reasonably quickly.</p>
<p>If a thread is interrupted when it is <em>not</em> blocked, its interrupted status is set, and it is up to the activity being cancelled to poll the interrupted status to detect interruption. In this way interruption is “sticky”–if it doesn’t trigger an <em>InterruptedException</em>, evidence of interruption persists until someone deliberately clears the interrupted status.</p>
<p>Calling interrupt does not necessarily stop the target thread from doing what it is doing; it merely delivers the message that interruption has been requested.</p>
<p>A good way to think about interruption is that it does not actually interrupt a running thread; it just requests that the thread interrupt itself at the next convenient opportunity (cancellation points). Some methods, sunch as <code>wait</code>, <code>sleep</code> and <code>join</code> take such request or encounter an already set interrupt status upon entry. Well behaved methods may totally ignore such requests so long as they leave the interruption request in place so that calling code can do something with it. Poorly behaved methods swallow the interrupt request, thus denying code further up the call stack the opportunity to act on it.</p>
<p>The static <code>interrupted</code> method should be used with caution, because it cleans the current thread’s interrupted status. If you call <code>interrupted</code> and it returns <code>true</code>, unless you are planning to swallow the interruption, you should do something with it–either throw <code>InterruptedException</code> or restore the interrupted status by calling <code>interrupt</code> again.</p>
<h3 id="Interruption-policies"><a href="#Interruption-policies" class="headerlink" title="Interruption policies"></a>Interruption policies</h3><p>An interruption policy determines how a thread interprets an interruption request–what it does (if anything) when one is detected, what units of work are considered atomic with respect to interruption, and how quickly it reacts to interruption.</p>
<p>Tasks do not execute in threads they own; they borrow threads owned by a service such as a thread pool. Code that doesn’t own the thread (for a thread pool, any code outside of the thread pool implementation) should be careful to preserve the interruptted status so that the owning code can evetually act on it, even if the “guest” code acts on the interruption as well.</p>
<p>This is why most blocking library methods simply throw <code>InterruptedException</code> in response to an interrupt. They will never execute in a thread they own, so they implement the most reasonable cancellation policyfor task or library code: get out of the way as quickly as possible and communicate the interruption back to the caller so that code higher up on the call stack can take further action.</p>
<p>A task needn’t necessarily drop everything when it detects an interruption request–it can choose to postpone it until a more opportune time by remembering that it was interrupted, finishing the task it was performing, and then throwing <code>InterruptedException</code> or otherwise indicating interruption. This techinique can protect data structures from corruption when an acitivity is interrupted in the middle of an update.</p>
<p>A task should not assume anything about the interruption policy of its executing thread unless it is explicitly designed to run within a service that has specifc interrutpion policy. Whether a task interprets interruption as cancellation or takes some other action on interruption, it should take care to preserve the executing thread’s interrutpion status. If it is not simply going to propagate <code>InterruptedException</code> to its caller, it should restore the interruption status after catching <code>InterruptedException</code>:</p>
<p><code>Thread.currentThread().interrupt()</code>;</p>
<p>Just as task code should not make assumption about what interruption means to its executing thread, cancellation code should not make assumption about the interruption policy of arbitrary thread. A thread should be interrupted only by its owner; the owner can encapsulate knowledge of the thread’s interruption policy in an appropriate cancellation mechanism such as shutdown method.</p>
<h3 id="Responding-to-interruption"><a href="#Responding-to-interruption" class="headerlink" title="Responding to interruption"></a>Responding to interruption</h3><p>When you call an interruptible blocking method such as <code>Thread.sleep</code> or <code>BlockingQueue.put</code>, there are two practical strategies for handling <code>InterruptedException</code>:</p>
<ul>
<li>Propagate the exception (possibly after some task specific cleanup), making your method an interruptible blocking method, too; or</li>
<li>Restore the interruption status so that code higher up on the call stack can deal with it.</li>
</ul>
<p>If you don’t want to or cannot propagate <code>InterruptedException</code> (perhaps because your task is defined by a <code>Runnable</code>), you need to find another way to preserve the interruption request. The standard way to do this is to restore the interrupted status by calling <code>interrupt</code> again. What you should <em>not</em> do is swallow the <code>InterruptedException</code> by catching it and doing nothing in the <code>catch</code> block, unless your code is actually implementting the interruption policy for a thread.</p>
<p>Activities that do not support cancellation but still call interruptible blocking methods will have to call them in a loop, retrying when interruption is detected. In this case, they should save the interruption status locally and restore it just before returning.</p>
<p>If your code does not call interruptible blokcing methods, it can still be made responsive to interruption by polling the current thread’s interrupted status throughout the task code. Choosing a polling frequency is a tradeoff between efficiency and responsiveness.</p>
<p>Cancellation can involve state other than the interruption status; interruption can be used to get the thread’s attention, and information stored elsewhere by the interrupting thread can be used to provide further instructions for the interrupted thread. For example, when a worker thread owned by a <code>ThreadPoolExecutor</code> detects interruption, it checks whether the pool is being shut down. If so, it performs some pool cleanup before terminating; otherwise it may create a new thread to restore the thread pool to the desired size.</p>
<h3 id="Cancellation-via-Future"><a href="#Cancellation-via-Future" class="headerlink" title="Cancellation via Future"></a>Cancellation via <code>Future</code></h3><p><code>ExecutorService.submit</code> returns a <code>Future</code> describing the task. <code>Future</code> has a <code>cancel</code> method that takes a boolean argument, <code>mayInterruptIfRunning</code>, and returns a value indicating whether the cancellation attempt was successful. (This tells you only whether it was able to deliver the interruption, not whether the task detected and acted on it.) When <code>mayInterruptIfRunning</code> is <code>true</code> and the task is currently running in some thread, then that thread is interrupted. Setting this argument to <code>false</code> means “don’t run this task if it hasn’t starated yet”, and should be used for tasks that are not designed to handle interruption.</p>
<p>Since you shouldn’t interrupt a thread unless you know its interruption policy, when is it OK to call <code>cancel</code> with an argument of <code>true</code>? The task execution threads created by the standard <code>Executor</code> implementations implement an interruption policy that lets tasks be cancelled using interruption, so it is safe to set <code>mayInterruptIfRunning</code> when cancelling tasks through their <code>Futures</code> when they are running in a standard <code>Executor</code>. You should not interrupt a pool thread directly when attempting to cancel a task, because you won’t know what task is running when the interrupted request is delivered–do this only through the task’s <code>Future</code>.</p>
<h3 id="Non-interruptible-blocking"><a href="#Non-interruptible-blocking" class="headerlink" title="Non-interruptible blocking"></a>Non-interruptible blocking</h3><p>Not all blocking methods or blocking mechanism are responsive to interruption; if a thread is blocked performing synchronous socket I/O or waiting to acquire an intrinsic lock, interruption has no effect other than setting the thread’s interrupted status. In this case, you can use technique for encapsulating nonstandard cancellatoin. For example, you can override the <code>Thread.interrupt</code> method to explicitly close the socket to make any threads blocked in <code>read</code> or <code>write</code> throw a <code>SocketException</code>.</p>
<h2 id="Stopping-a-thread-based-service"><a href="#Stopping-a-thread-based-service" class="headerlink" title="Stopping a thread-based service"></a>Stopping a thread-based service</h2><p>As with any other encapsulated object, thread ownership is not transitive: the application may own the service and the service may own the worker threads, but the application doesn’t own the worker threads and therefore should not attempt to stop them directly. Instead the service should provide <em>lifecycle methods</em> for shutting itself down that also shut down the owned threads.</p>
<h3 id="ExecutorService-shutdown"><a href="#ExecutorService-shutdown" class="headerlink" title="ExecutorService shutdown"></a><code>ExecutorService</code> shutdown</h3><p>In <a href="https://kanrourou.github.io/2021/05/03/book_reading_java_concurrency_6/" target="_blank" rel="noopener">Chapter 6</a>, we saw that <code>ExecutorService</code> offers two way to shut down:</p>
<ul>
<li>Gracefully shutdown with <code>shutdown</code>, and abrupt shutdown with <code>shutdownNow</code>.</li>
<li>In an abrupt shutdown, <code>shutdownNow</code> returns the list of tasks that had not yet started after attempting to cancel all actively executing tasks.</li>
</ul>
<p>The two differernt termination options offer a tradeoff between safety and responsiveness.</p>
<p>More sophisticated programs are likely to encapsulate an <code>ExecutorService</code> behind a higher-level service that provides its own lifecycle mehtod. Encapsulating an <code>ExecutorService</code> extends the ownership chain from application to service to thread by adding another link; each member of the chain manages the lifecycle of the services or threads it owns.</p>
<h3 id="Poison-pills"><a href="#Poison-pills" class="headerlink" title="Poison pills"></a>Poison pills</h3><p>Anoter way to convince a producer-consumer service to shut down is with a <em>poison pill</em>: a recognizable object placed on the queue that means “when you get this, stop.” With a FIFO queue, poison pills ensure that consumers finish the work on their queue before shutting down, since any work submitted prior to submitting the poison pill will be retrieved before the pill; producer should not submit any work after putting a poison pill on the queue.</p>
<p>Poison pills work only when the number of producers and consumers is known. For multiple producers, each producer place a pill on the queue and having the consumer stop only when it receives N<sub>producers</sub> pills. It can be extended to multiple consumers by having each prodcuer place N<sub>consumers</sub> pills on the queue. Poison pills work reliably only with unbounded queues.</p>
<h3 id="Limitation-of-shutdownNow"><a href="#Limitation-of-shutdownNow" class="headerlink" title="Limitation of shutdownNow"></a>Limitation of <code>shutdownNow</code></h3><p>When an <code>ExecutorService</code> is shut down abruptly with <code>shutdownNow</code>, it attempts to cancel the tasks currently in progress and returns a list of tasks that were submitted but never started so that they can be logged or saved for later processing. However, there is no general way to find out which tasks started but did not complete.</p>
<p><code>TrackingExecutor</code> below shows a techinque for determining which tasks were in progress at shutdown time. By encapsulating an <code>ExecutorService</code> and instrumenting <code>execute</code> (similar <code>submit</code>) to remember  which tasks were cancelled after shutdown, <code>TrackingExecutor</code> can identify which tasks started but did not complete normally:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrackingExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService exec;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Runnable&gt; tasksCancelledAtShutdown = </span><br><span class="line">        Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;Runnable&gt;());</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">getCancelledTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!exec.isTerminated())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(...);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Runnable&gt;(taskCancelledAtShutdown);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable runnable)</span> </span>&#123;</span><br><span class="line">        exec.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    runnable.run();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isShutDown()</span><br><span class="line">                        &amp;&amp; Thread.currentThread().isInterrupted())</span><br><span class="line">                        tasksCancelledAtShutdown.add(runnable);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TrackingExecutor</code> has an unavoidable race condition that could make it yield false positive: tasks that are identified as cancelled but actually completed. This arises because the thread pool could be shut down between when the last instruction of the task executes and when the pool records the task as complete. This is not a problem if task are <em>idempotent</em>.</p>
<h2 id="Handling-abnormal-thread-termination"><a href="#Handling-abnormal-thread-termination" class="headerlink" title="Handling abnormal thread termination"></a>Handling abnormal thread termination</h2><p>The leading cause of premature thread death is <code>RuntimeException</code>. Because these exceptions indicate a programming error or other unrecoverable problem, they are generally not caught. Instead they propagate all the way up the stack, at which point the default behaviors is to print a stack trace on the console and let the thread terminate.</p>
<p>Task-processing threads such as the worker threads in a thread pool or the Swing event dispatch thread spend their whole life calling unknown code through an abstraction barrier like <code>Runnable</code>, and these threads should be very skeptical that the code they call will be well bahaved. Accordingly, these facilities should call tasks within a <code>try-catch</code> block that catches unchecked exceptions, or within a <code>try-finally</code> block to ensure that if the thread exits abnormally the framework is informed of this and can take corrective action.</p>
<p>For example, for a <code>Runnable</code> you need to catch exception in the <code>run</code> method:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailToCatch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task());</span><br><span class="line">            thread.start;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Throws exception</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Since <code>Runnable</code> doesn’t throw exception, this <code>try-catch</code> block won’t catch the exception, so the thread will be ternimated because of uncaught exception. Instead, you can catch in the <code>run</code> method, the code below illustrate a way to structure a worker thread within a thread pool:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!isInterrupted())</span><br><span class="line">            runTask(getTaskFromWorkQueue());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        thrown = e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        threadExited(<span class="keyword">this</span>, thrown);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Uncaught-exception-handlers"><a href="#Uncaught-exception-handlers" class="headerlink" title="Uncaught exception handlers"></a>Uncaught exception handlers</h3><p>The Thread API also provides the <code>UncaughtExceptionHandler</code> facility, which lets you detect when a thread dies due to an uncaught exception.</p>
<p>When a thread exits due to an uncaught exception, the JVM reports this event to an application provided <code>UncaughteExceptionHandler; if no handler exits, the default behavior is to print the stack trace to</code>System.err`.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CaughtByHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task());</span><br><span class="line">        thread.setUncaughtExceptionHandler(<span class="keyword">new</span> ExceptionHandler());</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExceptionHandler</span> <span class="keyword">implements</span> <span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>When it comes to set an <code>UncaughtExceptionHandler</code> for pool threads, you need to be cautious since you don’t which thread the task will be run on. For example, when catching exception in <code>execute</code>, the below one doesn’t work:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailToCatchExecute</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task());</span><br><span class="line">        thread.setUncaughtExceptionHandler(<span class="keyword">new</span> ExceptionHandler());</span><br><span class="line">        exec.execute(thread);</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Because the <code>Runnable</code> we set the <code>UncaughtExceptionHandler</code> on is not the thread which will run the task.</p>
<p>Instead you can set the handler in the <code>run</code> method, since we knows which thread is running the task at this point:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CatchExecute</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        exec.execute(<span class="keyword">new</span> ThreadPoolTask);</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTask</span> <span class="title">implments</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread.currentThread().setUcaughtExceptionHandler(<span class="keyword">new</span> ExceptionHandler());</span><br><span class="line">        <span class="comment">// Throws exception...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Also, you can provide a <code>ThreadFactory</code> to the <code>Executor</code> constructor, so it allows the owner of the thread to change its <code>UncaughtExceptionHandler</code>. The standard thread pools allow an uncaught task exception to termnated the pool thread, but use a <code>try-finally</code> block to be notified when this happens so the thread can be replaced.</p>
<p>Exceptions thrown from tasks make it to the uncaught exception handler only for tasks submitted with <code>execute</code>; for tasks submitted with <code>submit</code>, any thrown exception, checked or not, is considered to be part of the task’s return status. If a task submitted with <code>submit</code> terminates with an exception, it is rethrown by <code>Future.get</code>, wrapped in an <code>ExecutionException</code>.</p>
<h2 id="JVM-shutdown"><a href="#JVM-shutdown" class="headerlink" title="JVM shutdown"></a>JVM shutdown</h2><p>The JVM can shut down in either an orderly or abrupt manner. An orderly shutdown is initiated when the last normal (nondaemon) thread terminates, someone calls <code>System.exit</code>. It can also be shut down abruptly by calling <code>Runtime.halt</code> or by killing the JVP process through the operating system.</p>
<h3 id="Shutdown-hooks"><a href="#Shutdown-hooks" class="headerlink" title="Shutdown hooks"></a>Shutdown hooks</h3><p>In an orderly shutdown, the JVM first starts all registered <em>shutdown hooks</em>. The JVM makes no guarantees on the order in hwich shutdown hooks are started. When all shutdown hooks have completed, the JVM may choose to run finalizers if <code>funFinalizersOnExit</code> is <code>true</code>, and then halts. The JVM makes no attempts to stop or interrupt any application threads that are still running at shutdown time; they are abruptly terminated when the JVM eventually halts. If the shutdown hooks or finalizers don’t complete, then the orderly shutdown process “hangs” and the JVM must be shut abruptly. In an abrupt shutdown, the JVM is not required to do aything other than halt the JVM; shutdown hooks will not run.</p>
<p>Shutdown hooks should be thread-safe. Further, they should not assumptions about the state of the application or about why the JVM is shutting down. Finally, they should exit as quickly as possible.</p>
<h3 id="Daemon-threads"><a href="#Daemon-threads" class="headerlink" title="Daemon threads"></a>Daemon threads</h3><p>Sometimes you want to create a thread that performs some helper function but you don’t want the existence of this thread to prevent the JVM from shutting down. This is what <em>daemon threads</em> are for.</p>
<p>Threads are devided into two types: normal threads and daemon threads. When the JVM starts up, all the threads it creates (such as garbage collector and other housekeeping threads) are daemon threads, except the main thread. When a new thread is created, it inhertis the daemon status of the thread that creates it, so by default any threads created by the main thread are also normal threads.</p>
<p>Normal threads and daemon threads differs only in what happens when they exit. When a thread exits, the JVM performs an inventory of running threads, and if the only threads that are left are deamon threads, it initiates an orderly shutdown. When the JVM halts, any remaining daemon threads are abandoned–<code>finally</code> blocks are not executed, stacks are not unwound–the JVM just exits.</p>
<h3 id="Finalizer"><a href="#Finalizer" class="headerlink" title="Finalizer"></a>Finalizer</h3><p>The garbage collector treats objects that have a nontrivial <code>finalizer</code> method specially: after they are reclaimed by the collector, <code>finalizer</code> is called so that persistent resources can be released.</p>
<p>Since finalizers can run in a thread managed by the JVM, any state accessed by a finalizer will be accessed by more than one thread and therefore must be accessed with synchronization. Finalizer offers no guarantees on when or even if they run, and they impose a significant perfomance cost on objects with nontrivial finalizers.</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Book-Reading/" rel="tag"># Book Reading</a>
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/Concurrency/" rel="tag"># Concurrency</a>
              <a href="/tags/CPJ/" rel="tag"># CPJ</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/05/16/book_reading_csapp_2_floating_point/" rel="prev" title="Book Reading: CSAPP, Chapter 2, 浮点数的表示和运算">
      <i class="fa fa-chevron-left"></i> Book Reading: CSAPP, Chapter 2, 浮点数的表示和运算
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/04/27/fix_valine_leancloud_bug/" rel="next" title="修复使用LeanCloud国际版时Valine阅读量和评论的bug">
      修复使用LeanCloud国际版时Valine阅读量和评论的bug <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Task-cancellation"><span class="nav-number">1.</span> <span class="nav-text">Task cancellation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Interruption"><span class="nav-number">1.1.</span> <span class="nav-text">Interruption</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Interruption-policies"><span class="nav-number">1.2.</span> <span class="nav-text">Interruption policies</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Responding-to-interruption"><span class="nav-number">1.3.</span> <span class="nav-text">Responding to interruption</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cancellation-via-Future"><span class="nav-number">1.4.</span> <span class="nav-text">Cancellation via Future</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Non-interruptible-blocking"><span class="nav-number">1.5.</span> <span class="nav-text">Non-interruptible blocking</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stopping-a-thread-based-service"><span class="nav-number">2.</span> <span class="nav-text">Stopping a thread-based service</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ExecutorService-shutdown"><span class="nav-number">2.1.</span> <span class="nav-text">ExecutorService shutdown</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Poison-pills"><span class="nav-number">2.2.</span> <span class="nav-text">Poison pills</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Limitation-of-shutdownNow"><span class="nav-number">2.3.</span> <span class="nav-text">Limitation of shutdownNow</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Handling-abnormal-thread-termination"><span class="nav-number">3.</span> <span class="nav-text">Handling abnormal thread termination</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Uncaught-exception-handlers"><span class="nav-number">3.1.</span> <span class="nav-text">Uncaught exception handlers</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM-shutdown"><span class="nav-number">4.</span> <span class="nav-text">JVM shutdown</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Shutdown-hooks"><span class="nav-number">4.1.</span> <span class="nav-text">Shutdown hooks</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Daemon-threads"><span class="nav-number">4.2.</span> <span class="nav-text">Daemon threads</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Finalizer"><span class="nav-number">4.3.</span> <span class="nav-text">Finalizer</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="hehejun"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">hehejun</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hehejun</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="Symbols count total">109k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">1:40</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  


<script>
NexT.utils.loadComments(() => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.4.18/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el: '#comments',
      verify: false,
      notify: false,
      appId: 'PKvEM4W15eyM8pCk7qvGlvYF-MdYXbMMI',
      appKey: 'u3RYtOW2Dcu1hAgNEtjsAMip',
      placeholder: "Just go go",
      avatar: 'mm',
      meta: guest,
      pageSize: '10' || 10,
      visitor: true,
      lang: '' || 'zh-cn',
      path: location.pathname,
      recordIP: false,
      serverURLs: 'https://pkvem4w1.api.lncldglobal.com'
    });
  }, window.Valine);
});
</script>

</body>
</html>
